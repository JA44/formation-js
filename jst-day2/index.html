<!doctype html>
<html lang="fr">

  <head>
    <meta charset="utf-8">
    <title>JS Total • 2ème partie, 17/12/2014</title>

    <meta name="author" content="Christophe Porteneuve">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/js-attitude.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/tomorrow.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      if (window.location.search.match( /print-pdf/gi))
        document.write( '<link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="all">' );
      else
        document.write( '<link rel="stylesheet" href="css/print/paper.css" type="text/css" media="print">' );;
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body class="no-anims">

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="intro">
          <h1>JS Total</h1>
          <h3 data-marker="intro-date">2ème partie, 17/12/2014</h3>
          <h4 data-marker="intro-trainers">Jonathan Blanchet @ JS Attitude</h4>
          <script>
            // Delicously hacky. Look away.
            if( navigator.userAgent.match( /(iPhone|iPad|iPod|Android)/i ) ) document.write( '<p style="color: rgba(0,0,0,0.3); text-shadow: none;">('+'Tap to navigate'+')</p>' );
          </script>
        </section>

        <section id="overview">
          <h1>JS Total</h1>
          <h4 data-marker="overview-dates">4 journées du 16 au 19 décembre</h4>

          <ol>
            <li><span data-marker="day2">Aujourd’hui</span> : Outils, DevTools, modules et début SPA</li>
            <li><span data-marker="day3">Demain</span> : développement d’une SPA complète</li>
            <li><span data-marker="day4">Vendredi</span> : industrialisation et web mobile</li>
          </ol>
        </section>

        <section id="debug-consoles">
          <section class="chapter">
            <h1>Déboguer le desktop</h1>
            <h4>Console et panneaux avancés</h4>

            <p>(et aussi : <a href="http://discover-devtools.codeschool.com/">Discover DevTools</a> et <a href="http://www.youtube.com/playlist?list=PLNYkxOF6rcIBQ8j3J_PyM8JLAGKqZRByw">The Breakpoint</a>)</p>

            <aside class="notes" data-markdown>
              configuration de la console

              chrome://flag :

              * chercher harmony => activer (promesses, générateur)
              * Activer les expérimentations dans les outils de développement
              * relancer chrome

              Cmd Alt J => ouvrir la console JS

              Configurer les outils de dev :

              * disable cache
              * source maps + cocher autoreload generated CSS
              * log XHR
              * show advanced heap snapshot
              * - enable Cmd + 1-9 shortcut to switch panels
              * Experiments : support async

              Faire un tour dans les shortcuts

            </aside>
          </section>

          <section id="console">
            <h1>La console</h1>

            <p>Bien plus que <code>console.log</code> !</p>
            <p>Complétion, Cmd+K/Ctrl+L, Shift+Return…</p>
            <p><a href="http://www.youtube.com/watch?v=4mf_yNLlgic&noredirect=1">Console Power User</a> !</p>
            <p>time / timeEnd</p>
            <p>dir, table</p>
            <p>$_, <em>Save As Global Variable</em>, copy</p>
            <p>$0 / inspect(el), Force Element State, $$</p>
            <p>monitorEvents, Break On… (+ Elements > Event Listeners)</p>

            <aside class="notes" data-markdown>
              .log : objets complexes, multi argument, .debug, .info, .warn, .error (stack trace)

* console.groupCollapsed('module 1')
* console.log('init');
* console.log('XHR');
* console.group('sous-module');
* console.log('autre');
* console.groupEnd();
* console.groupEnd();


* console.table( [
* ['name', 'age'],
* ['chris', 36],
* ['JP', 34]
* ]);

              * changement de contexte de frame
              * $- : faire un new Date(), puis $-
              * force element state : lien "console power user"
              * édition de CSS, colorpicker
              * monitorEvents( $0 ). $0 à $6
              * $$('p')
              * keys( document ) + copy( keys(document) )
            </aside>
          </section>

          <section id="panel-scripts">
            <h1>Le panneau Sources</h1>

            <p>Le pas à pas, en détail</p>
            <p>Des breakpoints sur <strong>tout</strong> !</p>
            <p>Expressions espions (watches)</p>
            <p>Pile d'appels (call stack).  Noms de fonctions.</p>
            <p>Portée</p>
            <p>Gestion des exceptions</p>
            <p><i>Beautifying</i> !</p>

            <aside class="notes" data-markdown>
              Démo sur la fonction de filtrage d'API de [l'API Prototype](http://api.prototypejs.org).

              * chercher une fonction filter (Ctrl+Shift+F)
              * breakpoint, pas à pas IN / OUT / OVER
              * breakpoint conditionnel (value.length > 4)
              * DOM breakpoint sur ul#search_results => on retrouve notre fonction filter
              * montrer closures (y compris quand elles ne sont pas là faute d'utilisation de la portée englobante)

              Sur Twitter :

              * démo break on XHR (sur action reply par ex.)
              * beautifying - pretty print
              * break on DOM events

              scp closure-debugger-hoisting-exception.html di:public/debug.html

              Sur [closure-debugger-hoisting-exception.html](http://delicious-insights.com/js-total/debug.html) :

              * mot clé debugger;
              * break on error
            </aside>
          </section>

          <section id="panel-resources">
            <h1>Le panneau Resources</h1>

            <p>Tout ce qui est stocké en local :</p>

            <ul>
              <li>Naviguer dans les sources ; iframes ; workers !</li>
              <li>Ressources chargées (catégorisées)</li>
              <li>Cookies</li>
              <li>Stockage session et local</li>
              <li>Bases de données</li>
              <li>AppCache</li>
            </ul>

            <aside class="notes" data-markdown>
              C'est le meilleur moyen de triturer ses cookies.  Indiquer qu'on utilisera les stockages local et session, ainsi qu'AppCache, le lendemain.

              appui long sur reload pour vider le cache (window only ?)
            </aside>
          </section>

          <section id="panel-network">
            <h1>Le panneau Network</h1>

            <p>Analyse des performances de chargement</p>
            <p>Distinction latence / chargement</p>
            <p>Visualisation détaillée (en-têtes, corps, preview…)</p>
            <p>Mode persistent (record)</p>
            <p>Toute l'activité : ressources, XHR, WebSockets…</p>

            <aside class="notes" data-markdown>
              PPC + network XHR + JSON + console.table

              Bien montrer les recoins des requêtes, le détail du timing, les previews, la copie cURL, parler des trucs HAR, et le Replay XHR (qui ne reprend pas les handlers, ceci dit ; juste pratique pour vérifier qu'on a débogué la couche serveur quand elle chiait à tort).

              clear cache, clear cookie, replay XHR
            </aside>
          </section>

<!--
          <section id="panel-timeline">
            <h1>Le panneau Timeline</h1>

            <p>Analyse des performances d'exécution</p>
            <p>Chargement / Parsing / Rendering / Painting</p>
            <p>Groupes asynchrones</p>
            <p>Monitoring événements, FPS, RAM ; GC !</p>
            <p>Mode persistent, là aussi.</p>
            <p>Réduction du bruit (&lt; 15ms)</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Profiles.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              timeline event / frame / memory avec reveal.js


            </aside>
          </section>

          <section id="panel-profiles">
            <h1>Le panneau Profiles et Rendering</h1>

            <p>Préalable <strong>obligatoire</strong> à l'optimisation !</p>
            <p>Pas seulement JS : sélecteurs CSS et occupation RAM</p>
            <p>Profils/snapshots nommés + persistence possible</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Timeline.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              rendering : Esc, avec FPS meter et paint rectangles
            </aside>
          </section>
-->
          <section id="panel-audits">
            <h1>Le panneau Audits</h1>

            <p>Genre DOM Monster + GTMetrix…</p>
            <p>Performances <em>loadtime</em> + <em>runtime</em></p>
            <p>État actuel ou dès chargement</p>
            <p>Voir aussi <a href="http://javascriptrocks.com/performance/">JS Performance Rocks!</a></p>

            <aside class="notes" data-markdown>
              Montrer vite fait mais préférer PageSpeed Insights (français, plus exhaustif, file les ressources déjà optimisées). JP, tu as peut-être des conseils d'exploit/démo/liaisons ici, sans déborder en temps ?
            </aside>

          </section>

          <section id="panel-emulation">
            <h1>Le tiroir Émulation</h1>

            <p>Émuler le touch, la géoloc, l'accéléromètre</p>
            <p>CSS print</p>
            <p>RWD, taille d'écran et densité de pixels</p>
            <p>Network Throttling</p>
            <p>User Agent</p>

            <aside class="notes" data-markdown>
              raccourci Esc de n'importe où
            </aside>

          </section>

        </section>

        <section id="debug-remote">
          <section class="chapter">
            <h1>Déboguer à distance</h1>
            <h4>sur les mobiles</h4>
          </section>

          <section id="weinre">
            <h1>Weinre</h1>
            <h4>WEb INspector REmote</h4>

            <p>Le WebInspector de WebKit (Chrome/Saf), connecté à un navigateur mobile via un serveur</p>
            <p>Fait partie de Apache Cordova (ex Phonegap)</p>
            <p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/">Les docs chez Apache</a></p>

            <aside class="notes" data-markdown>
              En parler parce que c'est la base, mais préciser qu'on utilisera toujours ça intégré à un autre système.

              * installation facile via NodeJS
              * Lance un serveur
              * Injection de script dans la page cible
              * affiche la vieille interface des debug tools webkit
              * du coup ça marche sur Android 2.3, vieux iOS, windows phone, webViews, TVs …

            </aside>
          </section>

          <section id="adobe-edge-inspect">
            <h1>Adobe Edge Inspect</h1>
            <h4>(ex Adobe Shadow)</h4>

            <p>Solution complète incluant Weinre (date un peu)</p>
            <p>Logiciel desktop + extension Chrome + app mobile</p>
            <p>Nécessite un compte Adobe Creative Cloud<br/>(gratuit pour 1 périphérique)</p>
            <p>Captures d'écran, etc.</p>
            <p><a href="http://html.adobe.com/edge/inspect/">Ça se passe ici</a></p>

            <aside class="notes" data-markdown>
              Faire une démo avec soit iPhone soit Android (soit les deux ? Ou une tablette et un téléphone…).  Penser à bien mettre tous les devices sur le réseau du laptop, et à utiliser l'IP du laptop (pas de DNS approprié en local).

              montrer navigator.userAgent, édition de CSS, screenshot, plein écran …

              À noter que si vous avez un besoin récurrent de montrer du mobile en vidéo-projection, [Reflector](http://www.airsquirrels.com/reflector/) ne coûte presque rien et déchire.
            </aside>
          </section>

          <section id="android-specific">
            <h1>Spécifiques Android</h1>

            <p>Chrome : <a href="https://developers.google.com/chrome/mobile/docs/debugging">debugging distant via la version desktop</a> en USB (nécessite toutefois le SDK Android + la config en mode développement du téléphone)</p>
            <aside class="notes" data-markdown>
              Android :

              * connecter l'USB
              * "à propos de l'appareil"
              * appuyer 7 fois sur le numéro de version
              * menu Options de développement
              * activer le debug USB
              * chrome://inspect/#devices
              * windows : + http://developer.android.com/tools/extras/oem-usb.html
              * sélection du device (avoir lancé chrome)
            </aside>
          </section>

          <section id="mobile-safari-specific">
            <h1>iOS / Mobile Safari</h1>

            <p>Sur iOS 5.x, on avait <a href="http://www.iwebinspector.com/">iWebInspector</a></p>
            <p>Depuis iOS 6 <a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html#//apple_ref/doc/uid/TP40007874-CH2-SW2">on peut connecter via USB</a> Safari Desktop</p>
            <p>On espère pour bientôt : <a href="https://github.com/google/ios-webkit-debug-proxy">iOS WebKit Debug Proxy</a> (Lion+)</p>

            <aside class="notes" data-markdown>
              iWebInspector :

              * peut encore être utilisé pour les webview
              * MacOS 10.6 et 10.7 (donc pas 10.8 Mountain Lion)
              * breakpoints, profiling et le reste

              WebInspector Safari :
              * Avoir configuré sur iOS : Réglages > Safari > Avancé > Inspecteur Web. Lancer une page
              * Safari 7 > Développement > iPhone de ….

              iOS WebKit Debug Proxy :
              * Mac / linux, pas windows
              * encore un peu brut, ne marche pas à tous les coups
              * Lion+, Xcode 5



            </aside>
          </section>

          <section id="mobile-other-specific">
            <h1>Les autres</h1>

            <p>Firefox (Fennec) : depuis la 15, <a href="https://hacks.mozilla.org/2012/08/remote-debugging-on-firefox-for-android/">debugging distant</a> simple à configurer, via TCP/IP (ou ADB forwarding).  Et <strong>aussi via Weinre</strong>.</p>

            <p>Windows Phone : <a href="http://blogs.msdn.com/b/visualstudioalm/archive/2014/04/04/diagnosing-mobile-website-issues-on-windows-phone-8-1-with-visual-studio.aspx">Visual Studio 2013</a>, et encore uniquement pour Windows Phone 8.1… Mais complet.  Et <strong>aussi via Weinre</strong></p>

            <p>Opera Mobile : <a href="http://www.opera.com/dragonfly/documentation/remote/">Dragonfly</a></p>

            <aside class="notes" data-markdown>
            </aside>
          </section>
        </section>

        <section id="preprocessors">
          <section class="chapter">
            <h1>Préprocesseurs</h1>
            <h4>Parce que des fois on en veut plus</h4>

            <aside class="notes" data-markdown>

            L'idée d'un pré-proc remonte avant CSS1

              * notions de variables (constantes), fonctions (mixin), conditions …

              Évoquer Less et Sass (de toute façon dans la démo SourceMaps).

              * Less lent, syntaxe discutable (@ ou . pour un mixin ), pas de gestion d'erreur
              * Less = bootstrap (un pote) => connu
              * Sass : + de possibilités que Less, code généré efficace. Depuis Sass 3, interprète correctement le .css
              * Compass : librairie de mixin pour Sass, mais bugs et parfois très lourd (grille = 1.2Mo). Préférer micro-lib ou bourbon.io (montrer juste la démo en haut de page)
            </aside>
          </section>

          <section id="stylus">
            <h1>Stylus</h1>

            <p>J'aime &hearts; :-)</p>
            <p>Par les types qui font Socket.IO et plein de trucs Node</p>
            <p>Syntaxe flexible, adaptable à vos goûts</p>
            <p>Transparence des mixins/prefixers</p>
            <p>Petites syntaxes <strong>qui tuent</strong></p>
            <p><a href="http://learnboost.github.com/stylus/">learnboost.github.com/stylus</a></p>

            <aside class="notes" data-markdown>
              Stylus :

              * Par <a href="https://github.com/visionmedia">le malade</a> qui fait aussi express, jade (template HTML), mocha, commander…
              * syntaxe à la coffee mais configurable
              * renvoie des erreurs, réf au parent, images inline
              * librairie de mixins Nib : http://visionmedia.github.io/nib/ (voir les mixins vendor-prefix, clearfix, ellipsis et dégradés )
            </aside>
          </section>

          <section id="stylus-demo">
            <h1>Stylus : exemple</h1>

            <pre><code class="stylus">overflow()
  if arguments[0] == ellipsis
    ellipsis()
  else
    overflow: arguments

size()
  if length(arguments) == 1
    width: arguments[0]
    height: arguments[0]
  else
    width: arguments[0]
    height: arguments[1]

box-shadow()
  vendor('box-shadow', arguments, only: webkit official)</code></pre>
          </section>

          <section id="coffeescript">
            <h1>CoffeeScript</h1>

            <p>Juste une tuerie™</p>
            <p>Transpiler JavaScript (y'en a plein)</p>
            <p>Pas <strong>du tout</strong> que pour les n00bs : chouchou des gourous aussi…  Inspire énormément ES.next.</p>
            <p>Évite les pièges, promeut les bonnes pratiques, améliore les perfs, sauve des chatons.</p>
            <p>De plus en plus de libs et frameworks majeurs l'utilisent comme langage de dev.</p>
            <p><a href="http://coffeescript.org/">coffeescript.org</a></p>

            <aside class="notes" data-markdown>
              * 4 ans, inspire ES.Next
              * également backbone, underscore, doco

              * arguments par défaut
              * classes : constructeur, méthodes
              * héritage avec extends
              * binding du contexte (@ = this), fat arrow (comme ES6)
              * égalité stricte
              * array slice
              * jamais de variable globale
              * plus de variable hiding
              * chained comparison
              * commentaire dans les RegExp
              * tout est expression=> les for peuvent renvoyer des valeurs
            </aside>
          </section>

          <section id="coffeescript-demo">
            <h1>Coffee : exemple</h1>

            <pre><code>awardMedals = (first, second, others...) ->
  gold   = first
  silver = second
  rest   = others

math =
  root:   Math.sqrt
  square: square
  cube:   (x) -> x * square x

foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'

yearsOld = max: 10, ida: 9, tim: 11

ages = for child, age of yearsOld
  "#{child} is #{age}"

letTheWildRumpusBegin() unless answer is no</code></pre>

            <aside class="notes" data-markdown>
              * splats (range les arguments en trop dans un tableau à part)
              * objet literal
              * unless (inverse du if)
              * templating


              Si on a le temps (on doit boucler la démo avant de partir déjeuner), on peut ici jouer un peu avec la console interactive du site de CoffeeScript.
            </aside>
          </section>

          <section id="sourcemap-demo">
            <h1>Source Maps</h1>
            <h2>Comment deboguer du code généré ?</h2>
            <p>Les pré-proc c'est joli, mais le navigateur ne lit que JS et CSS</p>
            <p>Idée de base : faire le lien entre le code généré et le code original.</p>
            <p>Marche aussi pour le code minifié, les concaténations…</p>
            <p>Comme à la maison : inspection des styles, point d'arrêt …</p>

            <aside class="notes" data-markdown>
              dans demos-day2:

              * montrer les sources (index + coffee + scss)
              * expliquer le watcher, le lancer, montrer que les fichiers ont été générés
              * afficher via localhost ()
              * montrer le réseau (.css et .js, puis sourcemap, puis .scss et .coffee)
              * inspecter le style du H1, de l'input
              * point d'arrêt JS
            </aside>
          </section>
        </section>

        <section id="what-can-we-use">
          <section class="chapter">
            <h1>À quoi a-t-on droit ?</h1>
            <h4>Et comment compenser ?</h4>
          </section>

          <section id="refs">
            <h1>Références</h1>

            <p>
              <a href="http://caniuse.com/">CanIUse</a>
              <span class="fragment">+ <a href="http://caniuse.com/#stats_import">Google Analytics</a> = <strong>Awesome</strong> !</span>
            </p>
            <p class="fragment"><a href="http://html5please.com/">HTML5 Please</a> : détails de prise en charge et polyfills</p>
            <p class="fragment"><a href="http://html5test.com/">HTML5Test</a>&nbsp;: et ton navigateur, il roxxe&nbsp;?</p>

            <aside class="notes" data-markdown>
              Faire une démo avec un de vos sites sur GA.  Penser à purger votre LocalStorage CIU avant, pour ne pas être d'entrée de jeu en mode Custom.  Attention, la beta en cours peut déconner sur le custom…
            </aside>
          </section>

          <section id="modernizr">
            <h1>Modernizr</h1>

            <p>In-page feature detection</p>
            <p>Sans doute le seul script forcément à chargement synchrone, et dans le head :-)</p>
            <p>À peu près tous les aspects de CSS2/3 et « HTML5 »</p>
            <p>Classes positives/négatives sur le document : évite au passage de saloper nos feuilles à coups de hacks CSS</p>
            <p><a href="http://modernizr.com/">modernizr.com</a></p>

            <aside class="notes" data-markdown>
              « Le seul script qui devrait être chargé en synchrone depuis le `&lt;head&gt;` »
            </aside>
          </section>

          <section id="polyfills">
            <h1>Polyfills</h1>

            <p>Un polyfill est un ersatz, un substitut qui tente de fournir une API identique (ou au moins équivalente) à celle d'une fonction non prise en charge par l'environnement (typiquement le navigateur)</p>
            <p>Y'en a <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">plein</a>&nbsp;!</p>
            <p>Les fameux <a href="http://code.google.com/p/ie7-js/">IEx.js</a> de Dean Edwards, <a href="http://raphaeljs.com/">Raphaël</a>, <a href="https://github.com/afarkas/html5shiv">html5shiv</a>, <a href="http://code.google.com/p/explorercanvas/">ExCanvas</a>, <a href="http://sublimevideo.net/">SublimeVideo</a>, <a href="http://socket.io/">Socket.IO</a>, <a href="https://github.com/kriskowal/es5-shim/">es5-shim</a>…</p>
          </section>
        </section>

        <section id="codebase">
          <section class="chapter">
            <h1>Organiser la codebase</h1>
          </section>

          <section id="modules">
            <h1>Modules</h1>

            <p><a href="http://requirejs.org/docs/why.html">Pourquoi des modules ?</a></p>
            <p><a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a></p>
            <p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a></p>
            <p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">Harmony</a></p>

            <aside class="notes" data-markdown>
              Introduire la notion avant de parler des formats :

              * grosse codebase, diviser pour mieux régner
              * réutilisation de code
              * gestion des dépendances complexes
              * pas de pollution globale
            </aside>
          </section>

          <section id="commonjs">
            <h1>CommonJS</h1>

            <p>Le format historique, synchrone, popularisé par Node</p>
            <p>On parle en fait de CommonJS/1.0 (plein d'extensions…)</p>
            <p>Très facile à comprendre :</p>

            <br/>
            <p class="fragment"><code>exports.<i>key</i> = <i>value</i></code></p>
            <p class="fragment"><code><i>mod</i> = require('<i>pathspec</i>')</code></p>

            <aside class="notes" data-markdown>
              * la base de Node.js, Brunch et Browserify (chargeur de fichier concaténés)
              * on en fera dans la SPA de demain
              * Un fichier = un module
              * construit l'arbre des dépendances
              * Enrobage automatique donc obligatoire
              * toute variable doit être locale
              * renvoi de l'API publique avec exports.key ou module.exports
              * de l'autre côté : var machin = require('chemin') sans le .js
            </aside>
          </section>

          <section id="commonjs-2">
            <h1>CommonJS</h1>
            <p><img src="assets/commonjs.png"></p>
          </section>

          <section id="amd">
            <h1>AMD</h1>

            <p>Mais <a href="http://requirejs.org/docs/whyamd.html">pourquoi&nbsp;?</a></p>
            <p>Asynchronous Module Definition</p>
            <p>Conçu notamment pour les browsers</p>
            <p>Tout module CommonJS peut être « enrobé » en AMD</p>
            <p>Principal loader : <a href="http://requirejs.org/">RequireJS</a></p>
            <p>Clé de voute :</p>
            <br/>
            <p><code>define('<i>name</i>', [<i>path, …</i>], <i>cb</i>(<i>mod, …</i>) {})</code></p>

            <aside class="notes" data-markdown>
              * machin = require(truc) pas possible à cause de l'async, d'où callback
              * Enrobage manuel donc pas obligatoire…
              * grosse mode il y a qlqs années. est resté requireJS (et LabJS, yepnope.js …)

            </aside>
          </section>

          <section id="amd-2">
            <h1>AMD</h1>
            <p><img src="assets/amd.png"></p>
            <aside class="notes" data-markdown>
             * explicite avec define + return de l'API publique
             * nom du module peut être différent du nom du fichier (mais à configurer)
             * dépendances listées + référence locale
             * tri topologique et décision de téléchargement
            </aside>

          </section>

          <section id="harmony-modules">
            <h1>Modules Harmony</h1>

            <p><a href="http://jsmodules.io/">ES6 fournit une syntaxe native de modules</a>.</p>
            <p>Syntaxe souple, inspirée entre autres de Python.  Déjà disponible dans certaines implémentations préalables (Node 0.11, Chrome 35+, Firefox 25+…).</p>

            <p><a href="http://jsmodules.io/cjs.html">Comparez avec CommonJS</a> (mapping facile)</p>
            <p><a href="https://github.com/systemjs/systemjs">SystemJS</a> est un chargeur universel qui permet, dès maintenant, de faire collaborer les 3 types de modules et les scripts globaux, en cas de besoin.  Pour ES6, il respose sur l'excellent shim <a href="https://github.com/ModuleLoader/es6-module-loader">es6-module-loader</a>.</p>

            <aside class="notes" data-markdown>
              * prévu pour 2013, puis début 2014, mi-2014
              * marche dans Fx et options avancées de Chrome
              * même concepts que CommonJS mais pas compatible.
              * mais traducteurs et transpiler existent
              * concepts : modules synchrone, pré-compilation, résolution de l'arbre au parsing ou à l'exécution

              * 3 nouveaux mot clés : module, export, import
              * montrer la syntaxe sur le site
              * exemple jQuery : import $ from jquery
            </aside>
          </section>
        </section>

        <section id="frameworks">
          <section class="chapter">
            <h1>Frameworks</h1>
          </section>

          <section id="why-frameworks">
            <h1>Dis papa pourquoi ?</h1>

            <p><strong>Parce que !</strong></p>
            <p>Dès qu'on commence à avoir une masse de code, un formalisme et un socle bien testé et bien maintenu deviennent indispensables.  C'est comme pour le côté serveur !</p>

            <p>On perçoit quelques grandes catégories :</p>

            <p>La base : le squelette de MVC, sans plus</p>
            <p>Les <i>full clients</i> : la totale… pour le côté client</p>

            <aside class="notes" data-markdown>
              * Pour arretter de réinventer la roue
              * base MVC : pas de structure ou de syntaxe imposée
              * full clients : prends des décisions sur la vue, le templating, le routage, la communication serveur
              * full stack : généralement Node, comme Meteor. Dur à aborder
            </aside>
          </section>

          <section id="frameworks-basic">
            <h1>La base</h1>
            <h2><a href="http://backbonejs.org/">Backbone</a></h2>

            <p>Comme son nom l’indique, juste l’ossature critique</p>
            <p><strong>De loin le plus répandu</strong> (même sans marketing)</p>
            <p>Une couche modèle bien solide, à la base REST+JSON</p>
            <p>Couche routeur pas mal</p>
            <p>Couche vue minimaliste mais <strong>riche en BP</strong></p>
            <p>Énormément de <a href="http://backplug.io/">plugins</a> pour enrichir le tout</p>
            <p>(notamment <a href="http://marionettejs.com/">Marionette</a> pour ajouter du lourd côté vues)</p>

            <aside class="notes" data-markdown>
              * le plus connu (300 fois plus de sites que angular ou ember)
              * pérenne, open source, solide, syntaxe compréhensible
              * Model : solide, facilite communication serveur
              * routage : OK, gère pushState de HTML5
              * événements, facilite les bonnes pratiques jQuery
              * View (qui est plus un Controler en fait), on y rajoute parfois du Marionette ou du thorax (Handlebars)
            </aside>

          </section>

          <section id="frameworks-full-client">
            <h1>Full Client</h1>

            <p><a href="http://emberjs.com/">Ember.js</a></p>
            <p><a href="http://angularjs.org/">Angular.js</a></p>
            <p>Backbone + <a href="http://marionettejs.com/">Marionette</a></p>
            <p><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></p>
            <p><a href="http://walmartlabs.github.com/thorax/">Thorax</a></p>
            <p>…</p>
          </section>

          <section id="frameworks-angular">
            <h1>Full Client</h1>
            <h2><a href="http://angularjs.org/">Angular.js</a></h2>

            <p>Déjà ancien mais Google bombarde en marketing depuis 2010</p>
            <p>Sur-architecturé ; ratio puissance/complexité plutôt bas</p>
            <p>Soucis récurrents sur les choix de data sources, les scopes…</p>
            <p>Les directives et le dirty checking sont très lourds en perfs</p>
            <p>Angular 2, sera nettement mieux mais 10% compatible 1.</p>
            <p><strong>Beaucoup de bons concepts mais l'exécution est faiblarde.</strong></p>

            <aside class="notes" data-markdown>
              Angular :

              * pas du vrai open source : pull request ignorées
              * Google aime t il JS ? => dart, GWT
              * retour de stagiaires formation Node : marre d'angular, on passe à Ember
            </aside>
          </section>

          <section id="frameworks-ember">
            <h1>Full Client</h1>
            <h2><a href="http://emberjs.com/">Ember.js</a></h2>

            <p>Issu de SproutCore ; influencé par Rails</p>
            <p>Yehuda Katz &amp; Tilde (jQuery, Rails, Handlebars…)</p>
            <p>Bon ratio puissance/complexité</p>
            <p>Porte de sortie fréquente des « brûlés par Angular »</p>
            <p>Désormais 100% ES6 (transpilé), dont modules</p>
            <p>Data binding plus léger et performant, via HTMLBars</p>

            <aside class="notes" data-markdown>
              Ember :

              * récent, mais vient de sproutcore, pour l'appli iCloud
              * influence Rails
            </aside>
          </section>

          <section id="frameworks-over-backbone">
            <h1>Full Client</h1>
            <h2>Solutions basées Backbone</h2>

            <h3><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></h3>
            <p>Équivalent à Backbone + Marionette + du sucre syntaxique et des conventions de structuration et de nommage ; très sympa.</p>

            <h3><a href="http://walmartlabs.github.com/thorax/">Thorax</a></h3>
            <p>Le plus « battle-tested » au monde : au cœur de Walmart Mobile.  Énormément de services, factories, conventions, etc.  Archi industrielle adaptée aux (très) grosses applis clients.</p>
          </section>
        </section>

        <section>
          <section id="brunch" class="chapter">
            <h1><a href="http://brunch.io/">Brunch.io</a></h1>

            <p>Tout le monde parle de Grunt, Gulp, Broccoli…  Mais Brunch est là depuis 4 ans et les enterre tous en <strong>application assembly</strong>.</p>

            <p>Pas un exécuteur générique de tâches</p>
            <p>Une vraie pipeline optimisée pour le <a href="http://brunch.io/compare.html">build d'applis</a></p>
            <p>Extrêmement <strong>réactif</strong> : entre 60ms et 200ms de la sauvegarde de fichier à la fin des rebuilds appropriés.</p>
            <p>Énormément de puissance en très (très) peu de config ; repose plutôt sur plein de conventions (mais reste configurable)</p>
            <p>Écosystème très riche de <a href="http://brunch.io/plugins.html">plugins</a></p>

            <aside class="notes" data-markdown>
              Bizarrement, nous on préfère Brunch.  En gros, défonce Yeoman et ses énormes scripts Grunt en perf.  Mais Yeoman fait plein de trucs en plus, Brunch est un **assembleur d'appli** ; en revanche, à ce jeu-là, il enterre tout le monde (Grunt, Gulp, etc.).

              * Brunch en concurrence avec les nouveaux : gulp, brocoli

              Ça tombe bien, c'est là qu'on DL `spa-basis.zip`, qu'on la décompresse, `npm install` et `npm start`.  Du coup quand ça marche, on peut faire du Cmd+S et montrer le temps de réaction de Brunch :-)

              Pour les Windowsiens : activer l'option `usePolling` s'ils loupent des modifs / nouveaux fichiers (ça sera plus lent à réagir mais au moins ça réagira).
            </aside>
          </section>

          <section id="brunch-config">
            <h1>Config basique</h1>

            <p>Fichier <code>brunch-config.coffee</code> (ou <code>.js</code>)</p>

            <pre><code class="coffeescript">exports.config =
  files:
    javascripts:
      joinTo: 'app.js'
    stylesheets:
      joinTo: 'app.css'
    templates:
      joinTo: 'app.js'</code></pre>

            <p>JS = sources ES3/5/6, TypeScript, CoffeeScript, etc.</p>
            <p>Styles = sources CSS, SASS, LESS, Stylus, etc.</p>
            <p>Templates = sources Handlebars, Jade, etc.</p>
          </section>

          <section id="brunch-output">
            <h1>Ce que ça fait</h1>

            <ol>
              <li>Transpiling (ES6, CoffeeScript, TypeScript…)</li>
              <li>Préprocesseurs (LESS, SASS, Stylus…)</li>
              <li>Précompilation de templates vers JS (Handlebars, Jade…)</li>
              <li>Enrobage en modules (par défaut CommonJS)</li>
              <li>Concaténation intelligente</li>
              <li>Source Maps v3</li>
              <li>Minification optimale (JS, CSS) si en prod</li>
            </ol>

            <p>Si le plugin est présent, ses traitements sont automatiques !</p>

            <p>Mais aussi : spriting et optimisation des images, maintenance manifeste AppCache, injection live CSS, reloading si changement JS, etc.</p>
          </section>

          <section id="brunch-conventions">
            <h1>Conventions Brunch</h1>

            <p>Tout ça est configurable finement, mais par défaut :</p>

            <ul>
              <li>Les dossiers exploités sont <code>app/</code> et <code>vendor/</code></li>
              <li>Le dossier cible est <code>public/</code></li>
              <li>Les fichiers dont le nom démarre par <code>_</code> sont ignorés (on suppose qu'ils seront importés/inclus par d'autres)</li>
              <li>Le contenu des dossiers <code>assets/</code> est copié verbatim</li>
              <li>Les scripts dans les dossiers <code>vendor/</code> ne sont pas enrobés en modules, simplement concaténés</li>
              <li>Les autres scripts sont enrobés en modules CommonJS avec un nom dérivé de leur chemin sous <code>app/</code></li>
            </ul>
          </section>

          <section id="brunch-plugins">
            <h1>Plugins Brunch</h1>

            <p>Ce sont des modules Node qu'il suffit d'installer en local pour qu'ils soient pris en compte.</p>
            <p>Ils s'inscrivent sur un type de fichier (<code>javascript</code>, <code>stylesheets</code> ou <code>templates</code>) et 1+ extension/motif de fichier.</p>
            <p>Par exemple, <code>jade-brunch</code> s'inscrit sur le type <code>templates</code> pour l'extension <code>.jade</code>.</p>
            <p>Par défaut, Brunch ne traite aucun type de fichier d'office ; il lui faudrait au moins <code>javascript-brunch</code> pour s'occuper des <code>.js</code> et <code>css-brunch</code> pour s'occuper des <code>.css</code>.  Donc très léger !</p>

            <p>Y'en a <a href="http://brunch.io/plugins.html">des tonnes</a> :-)</p>
          </section>

          <section id="brunch-watch">
            <h1>Watcher Brunch</h1>

            <p>La commande <code>brunch build</code> fait un build one-shot, mais…</p>
            <p><code>brunch watch</code> poursuit en surveillant les dossiers définis pour mettre à jour, <strong>super vite</strong>, les fichiers cibles nécessaires.</p>
            <p>Elle peut même fournir un mini-serveur HTTP sur le dossier cible, avec <code>brunch watch --server</code></p>
          </section>

          <section id="brunch-prod">
            <h1>Brunch pour la prod</h1>

            <p>Par défaut, les fichiers produits sont orientés déceloppement : HTML indenté, JS et CSS non minifiés, etc.</p>
            <p>Pour une release, on demande à Brunch de produire les versions de production avec <code>brunch build --production</code></p>
            <p>Si les plugins idoines sont présents (ex. <code>uglify-js-brunch</code> et <code>clean-css-brunch</code>), une minification optimale est effectuée.  On peut aussi optimiser les images, etc.</p>
          </section>
        </section>

        <section>
          <section id="spa-intro" class="chapter">
            <h1>Notre p’tite SPA</h1>
          </section>

          <section id="what-does-it-do">
            <h1>Que fait-elle ?</h1>

            <p>Sorte de µ-Foursquare</p>
            <p>Regarde où on est, cherche des endroits où manger, check-in !</p>
            <p>Historise les check-ins</p>
            <p>Gestion pratique du offline</p>
          </section>

          <section id="spa-brunch-config">
            <h1>Config Brunch (1/2)</h1>

            <pre><code class="coffeescript">files:
  javascripts:
    joinTo: 'app.js'
  stylesheets:
    joinTo: 'app.css'
  templates:
    joinTo: 'app.js'

modules:
  nameCleaner: (path) ->
    path
      # Strip app/ and app/externals/ prefixes
      .replace /^app\/(?:externals\/)?/, ''
      # Allow -x.y[.z…] version suffixes in mantisses
      .replace /-\d+(?:\.\d+)+/, ''
      # Allow -fr lang suffixes in mantisses
      .replace '-fr.', '.'
</code></pre>
          </section>

          <section id="spa-brunch-config-2">
            <h1>Config Brunch (2/2)</h1>

            <pre><code class="coffeescript">plugins:
  appcache:
    externalCacheEntries: [
      'http://maps.gstatic.com/mapfiles/place_api/icons/bar-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/generic_business-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/restaurant-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/wine-71.png'
    ]
    network: ['*', 'http://*', 'https://*']

server:
  path: 'jst-server.coffee'

watcher:
  usePolling: true
</code></pre>
          </section>

          <section id="stack">
            <h1>La stack</h1>

            <p class="fragment"><a href="http://learnboost.github.io/stylus/">Stylus</a> et <a href="http://lesscss.org/">LESS</a> (<a href="http://getbootstrap.com/">Bootstrap</a>) pour les CSS</p>
            <p class="fragment"><a href="http://jade-lang.com/">Jade</a> pour le templating</p>
            <p class="fragment"><a href="http://backbonejs.org/">Backbone</a> pour le MVC côté client</p>
            <p class="fragment">W3C / HTML5 pour la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géolocalisation</a> et la <a href="https://developer.mozilla.org/fr/docs/%C3%89v%C3%A8nements_online_et_offline">détection offline</a></p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/DOM/Storage">sessionStorage</a> pour du stockage local transient</p>
            <p class="fragment"><a href="http://brian.io/lawnchair/">Lawnchair</a> pour l'abstraction de stockage local persistant</p>
            <p class="fragment"><a href="https://developers.google.com/maps/">Google Maps</a> pour l'obtention de POI où manger</p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/Utiliser_Application_Cache">ApplicationCache</a> pour le cache offline</p>
            <p class="fragment"><a href="http://momentjs.com/">Moment.js</a> pour l'horloge et <a href="http://underscorejs.org/">Underscore.js</a> pour l'algo</p>
            <p class="fragment"><a href="http://nodejs.org/">Node</a> et <a href="http://coffeescript.org/">CoffeeScript</a> pour le serveur de démo</p>
          </section>

          <section id="spa-boot">
            <h1>« Boot »</h1>

            <p>Bon, pour le moment, je passe sous Keynote…</p>
          </section>

          <section id="spa-steps">
            <h1>Pour aujourd'hui…</h1>

            <ol>
              <li>Faire tourner</li>
              <li>Récupérer et retenir le nom</li>
              <li>L’horloge</li>
              <li>Vues imbriquées</li>
              <li>Géolocalisation et Google Maps Places</li>
              <li>Modèle Backbone d’état UX</li>
            </ol>
          </section>

          <section id="spa-runit">
            <h1>Faire tourner</h1>
            <h3>le socle</h3>

            <pre><code data-trim data-noescape class="bash">
$ cd spa-basis
$ <u>npm install</u>
…
$ <u>npm start</u>

> js-total-spa@2.0.0 start …/spa-basis
> <u>brunch watch --server</u>

22 Oct 16:59:34 - info: starting custom server
Cannot load db.json
<b class="right">Listening on port 3333… WebSockets enabled.</b>
22 Oct 16:59:34 - info: custom server started, initializing watcher
22 Oct 16:59:35 - info: compiled 37 files and 1 cached into 2 files, copied…
            </code></pre>
          </section>

          <section id="spa-username">
            <h1>Retenir le nom</h1>

            <p>Bon vieux <code>prompt</code> + persistance dans <code><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#sessionStorage">sessionStorage</a></code></p>
            <p>Saisies pourries (<code>null</code>, whitespaces…), non persistées : nom l’aléatoire.  Première rencontre avec <a href="http://underscorejs.org">Underscore</a> :-)</p>
            <pre><code data-trim data-noescape class="javascript" data-file="lib/notifications.js">
var userName = <u>sessionStorage.</u>userName ||
  $.trim(<u>prompt</u>("Votre nom d’utilisateur"));
            </code></pre>

            <p>1er <code>getRenderData()</code> et variable dans un template Jade.</p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
getRenderData: function getHomeRenderData() {
  return { userName: userName };
}
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/templates/home.jade">
              span<u>= userName</u>
            </code></pre>
          </section>

          <section id="backbone-views">
            <h1>Backbone.View</h1>
            <h3>Rien que l’essentiel (mais bien choisi)</h3>

            <p><code><a href="http://backbonejs.org/#View">Backbone.View</a></code> ne fournit/impose que peu de chose, mais top</p>
            <p>Conteneur DOM : <code>el</code>, <code>$el</code></p>
            <p>Gen du conteneur : <code>tagName</code>, <code>id</code>, <code>className</code>, <code>attributes</code></p>
            <p>Modèle associé : <code>model</code> / <code>collection</code></p>
            <p>Lookup jQuery <span lang="en">prescoped</span> : <code>$</code> (on fait <code>this.$(…)</code>)</p>
            <p>Rendering : <code>render()</code></p>
            <p>Délégation d’événements : <code>events</code></p>
          </section>

          <section id="spa-clock">
            <h1>L’horloge</h1>

            <p>Injection initiale + mise à jour ultérieure.</p>
            <p>Le DOM doit être garanti à jour : <code>afterRender</code>.</p>
            <p>Bon vieux <code>setInterval(…, 1000)</code></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
<u>afterRender</u>: function afterHomeRender() {
  this.startClock();
},

// …

startClock: function startClock() {
  this._clock = this._clock || <u>this.$</u>('#ticker');
  <u>var that = this;</u>
  setInterval(function() {
    <u>that</u>.clock.text(<u>that</u>.getRenderData().now);
  }, 1000);
}
            </code></pre>
          </section>

          <section id="spa-nested-views">
            <h1>Vues imbriquées</h1>

            <p>Le pavé de gauche contient une vue complexe avec des tas de gestions spécifiques : on va en faire un contrôleur (<code>Backbone.View</code>) dédié, et l'intégrer dans la vue racine.</p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
var View = require('./view');

module.exports = View.extend({
  template: require('./templates/<u>check_in</u>')
});
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
var CheckInView = require('./check_in_view');

// …

  afterRender: function afterHomeRender() {
    this.startClock();
    <u>new CheckInView({ el: this.$('#checkInUI') }).render();</u>
  },
            </code></pre>
          </section>

          <section id="spa-geoloc">
            <h1>Géolocalisation</h1>

            <p>On a 2 modules qui nous découplent des technos sous-jacente :</p>
            <p><code>lib/location</code> par-dessus la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géoloc W3C</a></p>
            <p><code>lib/places</code> par-dessus <a href="https://developers.google.com/places/documentation/?hl=fr">Google Places</a></p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
afterRender: function() {
  this.fetchPlaces();
},

fetchPlaces: function() {
  <u>locSvc.getCurrentLocation</u>(function(lat, lng) {
    console.log(lat, lng);
    if (_.isString(lat)) {
      return;
    }
    <u>poiSvc.lookupPlaces</u>(lat, lng, function(places) {
      console.log(places);
    });
  });
}
            </code></pre>
          </section>

          <section id="spa-ux-model">
            <h1>Modèle Backbone</h1>
            <h3>pour l’état de l’UX</h3>

            <p>Passer par du data-binding pour contrôler proprement l’état de l’UI et l’UX en fonction des éléments de l’état de la vue (latitude, longitude, POIs, sélection, commentaire…).</p>

            <p>Le plugin le plus abouti est actuellement <a href="http://nytimes.github.io/backbone.stickit/">Backbone.StickIt</a></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
<u>bindings</u>: {
  // sélecteur CSS -> descripteur de binding, +/- avancé
  '#comment': 'comment',
  '#places': {
    observe: ['places', 'placeId'],
    onGet: function() { return this.getRenderData().placeList; },
    updateMethod: 'html'
  },
  // …
}
            </code></pre>
          </section>
        </section>

        <section id="next-day">
          <h1>À suivre…</h1>

          <h3>Coder la suite de la SPA</h3>

          <ul>
            <li>Persistence serveur</li>
            <li>Online/offline</li>
            <li>Stockage local</li>
            <li>Web sockets</li>
            <li>Routes multiples</li>
            <li>AppCache</li>
          </ul>

          <h3>À <span data-marker="next-day-name">demain</span>&nbsp;!</h3>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
